{"version":3,"file":"static-plugins.js","sourceRoot":"","sources":["../../src/plugins/static-plugins.ts"],"names":[],"mappings":";;AAAA,mCAAiC;AAGjC,4CAAsD;AACtD,8DAIkC;AAElC,MAAM,UAAU,GAAG,gBAAO,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;AAEhD,SAAS,oBAAoB,CAAC,IAAY,EAAE,KAAY;IACtD,aAAa;IACb,IAAI,KAAK,CAAC,IAAI,KAAK,kBAAkB,EAAE;QACrC,OAAO,IAAI,CAAC;KACb;IACD,OAAO,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,uBAAuB,IAAI,GAAG,CAAC,CAAC;AAChE,CAAC;AAED;;;;;;GAMG;AACU,QAAA,gBAAgB,GAIxB,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;;IACrB,IAAI,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;IACpC,IAAI,CAAC,WAAW,EAAE;QAChB,WAAW,SAAG,MAAM,CAAC,SAAS,0CAAE,WAAW,CAAC;QAC5C,2CAAyB,CAAC,WAAW,CAAC,CAAC;KACxC;IAED,IAAI,CAAC,aAAa,EAAE,WAAW,CAAC,GAAG,uCAAqB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IACvE,gDAAgD;IAChD,eAAM,CACJ,EAAC,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,cAAc,CAAA,EAC5B,iFAAiF,CAClF,CAAC;IAEF,IAAI,UAAiC,CAAC;IACtC,8DAA8D;IAC9D,IAAI,OAAO,aAAa,KAAK,UAAU,EAAE;QACvC,UAAU,GAAG,aAAa,CAAC;KAC5B;SAAM,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;QAC5C,IAAI;YACF,gCAAgC;YAChC,UAAU,GAAG,6CAA2B,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;SACtE;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,UAAU,EAAE;gBACd,IAAI,oBAAoB,CAAC,aAAa,EAAE,KAAK,CAAC,EAAE;oBAC9C,wDAAwD;oBACxD,OAAO,CAAC,GAAG,CAAC,0BAA0B,aAAa,GAAG,CAAC,CAAC;iBACzD;qBAAM;oBACL,0FAA0F;oBAC1F,OAAO,CAAC,GAAG,CAAC,2BAA2B,aAAa,GAAG,CAAC,CAAC;oBACzD,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBACnB,OAAO,CAAC,GAAG,EAAE,CAAC;iBACf;aACF;YACD,oGAAoG;YAEpG,qEAAqE;YACrE,gGAAgG;YAChG,IAAI,KAAK,CAAC,QAAQ,EAAE;gBAClB,IAAI,CAAC,WAAW;oBAAE,WAAW,GAAG,EAAE,CAAC;gBACnC,wGAAwG;gBACxG,WAAW,CAAC,cAAc,GAAG,KAAK,CAAC;gBACnC,UAAU,GAAG,KAAK,CAAC,QAAQ,CAAC;aAC7B;iBAAM;gBACL,8CAA8C;gBAC9C,MAAM,KAAK,CAAC;aACb;SACF;KACF;SAAM;QACL,MAAM,IAAI,oBAAW,CACnB,iCAAiC,OAAO,aAAa,EAAE,EACvD,qBAAqB,CACtB,CAAC;KACH;IACD,sBAAsB;IACtB,MAAM,GAAG,UAAU,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;IACzC,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC","sourcesContent":["import { boolish } from 'getenv';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { assert, PluginError } from '../utils/errors';\nimport {\n  assertInternalProjectRoot,\n  normalizeStaticPlugin,\n  resolveConfigPluginFunction,\n} from '../utils/plugin-resolver';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\nfunction isModuleMissingError(name: string, error: Error): boolean {\n  // @ts-ignore\n  if (error.code === 'MODULE_NOT_FOUND') {\n    return true;\n  }\n  return error.message.includes(`Cannot find module '${name}'`);\n}\n\n/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n */\nexport const withStaticPlugin: ConfigPlugin<{\n  plugin: StaticPlugin | ConfigPlugin | string;\n  fallback?: ConfigPlugin<{ _resolverError: Error } & any>;\n  projectRoot?: string;\n}> = (config, props) => {\n  let projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    projectRoot = config._internal?.projectRoot;\n    assertInternalProjectRoot(projectRoot);\n  }\n\n  let [pluginResolve, pluginProps] = normalizeStaticPlugin(props.plugin);\n  // Ensure no one uses this property by accident.\n  assert(\n    !pluginProps?._resolverError,\n    `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``\n  );\n\n  let withPlugin: ConfigPlugin<unknown>;\n  // Function was provided, no need to resolve: [withPlugin, {}]\n  if (typeof pluginResolve === 'function') {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      // Resolve and evaluate plugins.\n      withPlugin = resolveConfigPluginFunction(projectRoot, pluginResolve);\n    } catch (error) {\n      if (EXPO_DEBUG) {\n        if (isModuleMissingError(pluginResolve, error)) {\n          // Prevent causing log spew for basic resolution errors.\n          console.log(`Could not find plugin \"${pluginResolve}\"`);\n        } else {\n          // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n          console.log(`Error resolving plugin \"${pluginResolve}\"`);\n          console.log(error);\n          console.log();\n        }\n      }\n      // TODO: Maybe allow for `PluginError`s to be thrown so external plugins can assert invalid options.\n\n      // If the static module failed to resolve, attempt to use a fallback.\n      // This enables support for built-in plugins with versioned variations living in other packages.\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        // Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        // If no fallback, throw the resolution error.\n        throw error;\n      }\n    }\n  } else {\n    throw new PluginError(\n      `Plugin is an unexpected type: ${typeof pluginResolve}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n  // Execute the plugin.\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n"]}